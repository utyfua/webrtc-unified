/*!
 * WebRTC-client
 * @github   https://github.com/utyfua/webrtc-unified#readme
 * @npm      https://www.npmjs.com/package/webrtc-unified
 * @author   utyfua@gmail.com
 * @license  MIT
 */
(()=>{class EventEmitter{constructor(args){this._events={},this._events_once={}}on(eventName,callback,parent){this._events[eventName]=this._events[eventName]||[],this._events[eventName].push(callback),parent&&parent._parent_events.push([!1,eventName,callback])}once(eventName,callback,parent){if(this._events_once[eventName]=this._events_once[eventName]||[],parent){let original=callback;callback=(...args)=>{original.apply(this,args),parent._parent_events=parent._parent_events.filter(line=>!(line[0]&&line[1]===eventName&&line[2]===callback))}}this._events_once[eventName].push(callback),parent&&parent._parent_events.push([!0,eventName,callback])}oncePromice(eventName){return new Promice(callback=>this.once(eventName,callback))}off(eventName,callback){this._events[eventName]=this._events[eventName]&&this._events[eventName].filter(func=>func!==callback),this._events_once[eventName]=this._events_once[eventName]&&this._events_once[eventName].filter(func=>func!==callback)}offParent(parent){parent._parent_events=parent._parent_events.filter(([isOnce,eventName,callback])=>{let stay=!0,key=isOnce?"_events":"_events_once";return this[key][eventName]?(this[key][eventName]=this[key][eventName].filter(callback2=>callback!=callback2||(stay=!1,!1)),stay):stay})}emit(eventName,...args){let count=0;function proc(events){if(events)for(let i=0;i<events.length;i++)events[i].apply(this,args),count++}return proc(this._events[eventName]),proc(this._events_once[eventName]),delete this._events_once[eventName],count}}class WebRTCSimple extends EventEmitter{constructor(args){super(),this.args=args,this.localStreams=[],this.clients=[],this.rtcpeerConfig={sdpSemantics:"unified-plan",iceServers:[{url:"stun:stun.l.google.com:19302"}]},"undefined"!=typeof WebRTCSimple_TURN_SERVER&&this.rtcpeerConfig.iceServers.push(WebRTCSimple_TURN_SERVER)}setConnect(send){return this.connectionSend=send,this.emit("connect"),data=>this.connectionHandler(data)}connectionHandler(data){data&&"string"==typeof data.eventName&&"function"==typeof this["event_"+data.eventName]?this["event_"+data.eventName](data):console.log(data),this.emit(data.action,data)}getClient(clientId){return this.clients.find(client=>client.clientId==clientId)}joinRoom(roomId="default"){this.connectionSend({eventName:"joinRoom",roomId:roomId,localStreamsLength:this.localStreams.length})}event_getPeers(data){this.youId=data.youId,data.connections.forEach(clientId=>this.event_newPeerConnected({clientId:clientId},this))}event_newPeerConnected(data,receiver){new WebRTCSimpleClient({root:receiver||this,clientId:data.clientId,initer:receiver})}event_receiveOffer(data){let client=this.getClient(data.clientId);if(!client)return console.log("client not found",data.clientId);client.receiveOffer(data.offer)}setMedia({type:type,enable:enable,args:args}){let stream=this.localStreams.find(stream=>stream._type==type);if(void 0===enable&&(enable=!stream),stream)return!enable&&this.removeLocalStream(stream,!0);enable&&this.createStream({type:type,args:args})}async createStream({type:type,args:args}){if(-1===["display","video","audio"].indexOf(type))throw new Error("media bad type - "+type);let stream,mediaFunc="display"===type?"getDisplayMedia":"getUserMedia",opts="display"==type?{}:{[type]:args||!0};try{stream=await navigator.mediaDevices[mediaFunc](opts)}catch(e){return void this.emit("rejectUseMedia",type)}stream._type=type,this.addLocalStream(stream)}addLocalStream(stream){this.localStreams.push(stream),this.emit("addedLocalStream",stream,stream._type)}removeLocalStream(stream,needStop){needStop&&stream.getTracks()[0].stop(),this.localStreams=this.localStreams.filter(local=>local!==stream),this.emit("removedLocalStream",stream,stream._type)}}class WebRTCSimpleClient{constructor({root:root,clientId:clientId,initer:initer}){this.root=root,this.clientId=clientId,this.transceivers=[],this._parent_events=[],root.clients.push(this),this.initConnection(initer)}initConnection(initer){let root=this.root,peer=this.peer=new RTCPeerConnection(root.rtcpeerConfig);peer.ontrack=event=>{let stream=new MediaStream([event.track]);stream._type=event.track.kind,this.root.emit("addedRemoteStream",stream,stream._type,this.clientId),event.track.onmute=e=>this.root.emit("removedRemoteStream",stream,stream._type,this.clientId)},peer.oniceconnectionstatechange=event=>{if(peer.autofixTimer&&-1!=peer.autofixTimer&&(clearTimeout(peer.autofixTimer),peer.autofixTimer=-1),"failed"===peer.iceConnectionState)return peer.restartIce();console.log("peer state",peer.iceConnectionState)},peer.onnegotiationneeded=event=>{this.createOffer()},this.suncLocalStreams(),root.on("addedLocalStream",()=>this.suncLocalStreams(),this),root.on("removedLocalStream",()=>this.suncLocalStreams(),this)}async createOffer(){let peer=this.peer,offer=await peer.createOffer();await peer.setLocalDescription(offer),this.root.connectionSend({eventName:"sendOffer",offer:offer,clientId:this.clientId})}async receiveOffer(offer){let root=this.root,peer=this.peer;if(await peer.setRemoteDescription(offer),"offer"===offer.type){let answer=await peer.createAnswer();await peer.setLocalDescription(answer),root.connectionSend({eventName:"sendOffer",offer:answer,clientId:this.clientId}),peer.autofixTimer||(peer.autofixTimer=setTimeout(()=>this.createOffer(),200))}}suncLocalStreams(){let peer=this.peer,streams=this.root.localStreams,changed=!1,transceivers=peer.getTransceivers().filter(transceiver=>transceiver.sender.track&&"inactive"!=transceiver.currentDirection);streams.forEach(stream=>stream.getTracks().forEach(track=>{if(transceivers.length===(transceivers=transceivers.filter(transceiver=>transceiver.sender.track!==track)).length){peer.addTransceiver(track);changed=!0}})),transceivers.forEach(transceiver=>{peer.removeTrack(transceiver.sender),changed=!0})}}"object"==typeof module?module.exports=WebRTCSimple:window.WebRTCSimple=WebRTCSimple})();